name: Deploy to Staging

on:
  push:
    branches: [ develop, staging ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      deployment_mode:
        description: 'Deployment mode'
        required: true
        default: 'basic'
        type: choice
        options:
        - basic
        - enterprise

env:
  NODE_VERSION: '20'
  DEPLOYMENT_MODE: ${{ github.event.inputs.deployment_mode || 'basic' }}

jobs:
  validate:
    name: Validate Code & Infrastructure
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.changes.outputs.should_deploy }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 2

    - name: Check for changes
      id: changes
      run: |
        echo "should_deploy=true" >> $GITHUB_OUTPUT
        echo "Staging deployment - always deploy for testing"

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run linting
      run: npm run lint

    - name: Run type checking
      run: npm run type-check

    - name: Run tests
      run: npm run test

    - name: Validate infrastructure scripts
      run: |
        # Validate shell scripts
        find scripts/infra -name "*.sh" -exec shellcheck {} \;
        echo "âœ… Infrastructure scripts validated"

  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: validate
    if: needs.validate.outputs.should_deploy == 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Build application
      run: npm run build
      env:
        NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.STAGING_SUPABASE_URL }}
        NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.STAGING_SUPABASE_ANON_KEY }}
        NEXTAUTH_SECRET: ${{ secrets.STAGING_NEXTAUTH_SECRET }}
        NEXTAUTH_URL: ${{ secrets.STAGING_NEXTAUTH_URL }}

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: staging-build-artifacts
        path: |
          .next/
          public/
          package.json
          package-lock.json
        retention-days: 7

  deploy-staging:
    name: Deploy to Staging Environment
    runs-on: ubuntu-latest
    needs: [validate, build]
    if: needs.validate.outputs.should_deploy == 'true'
    environment: staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: staging-build-artifacts

    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: ${{ secrets.STAGING_SSH_PRIVATE_KEY }}

    - name: Add staging server to known hosts
      run: |
        ssh-keyscan -H ${{ secrets.STAGING_SERVER_HOST }} >> ~/.ssh/known_hosts

    - name: Deploy to staging server
      run: |
        # Copy deployment script to staging server
        scp scripts/infra/deploy-unified-enterprise.sh root@${{ secrets.STAGING_SERVER_HOST }}:/tmp/
        
        # Execute deployment on staging server
        ssh root@${{ secrets.STAGING_SERVER_HOST }} "
          chmod +x /tmp/deploy-unified-enterprise.sh
          
          DOMAIN='${{ secrets.STAGING_DOMAIN }}' \
          EMAIL='${{ secrets.EMAIL }}' \
          GITHUB_REPO='${{ github.repository }}' \
          GITHUB_TOKEN='${{ secrets.GITHUB_TOKEN }}' \
          DEPLOYMENT_MODE='${{ env.DEPLOYMENT_MODE }}' \
          ENABLE_MONITORING='false' \
          ENABLE_COOLIFY='false' \
          POSTGRES_PASSWORD='${{ secrets.STAGING_POSTGRES_PASSWORD }}' \
          DEBUG='true' \
          /tmp/deploy-unified-enterprise.sh
        "

    - name: Deploy application to staging
      run: |
        ssh root@${{ secrets.STAGING_SERVER_HOST }} "
          cd /opt/app || mkdir -p /opt/app && cd /opt/app
          
          # Stop existing application
          docker compose down || true
          
          # Clone/update repository
          if [[ -d .git ]]; then
            git pull origin ${{ github.ref_name }}
          else
            git clone https://github.com/${{ github.repository }}.git .
            git checkout ${{ github.ref_name }}
          fi
          
          # Create staging docker-compose
          cat > docker-compose.staging.yml <<EOF
          version: '3.8'
          services:
            app:
              build: .
              ports:
                - '3001:3000'
              environment:
                - NODE_ENV=staging
                - NEXT_PUBLIC_SUPABASE_URL=https://${{ secrets.STAGING_DOMAIN }}
                - NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.STAGING_SUPABASE_ANON_KEY }}
                - NEXTAUTH_SECRET=${{ secrets.STAGING_NEXTAUTH_SECRET }}
                - NEXTAUTH_URL=https://${{ secrets.STAGING_DOMAIN }}
              restart: unless-stopped
              healthcheck:
                test: ['CMD', 'curl', '-f', 'http://localhost:3000/health']
                interval: 30s
                timeout: 10s
                retries: 3
          EOF
          
          # Start application
          docker compose -f docker-compose.staging.yml up -d --build
        "

  test-staging:
    name: Test Staging Deployment
    runs-on: ubuntu-latest
    needs: deploy-staging
    
    steps:
    - name: Wait for staging startup
      run: sleep 90

    - name: Health check - Staging application
      run: |
        for i in {1..5}; do
          if curl -f https://${{ secrets.STAGING_DOMAIN }}/health; then
            echo "âœ… Staging application health check passed"
            break
          fi
          echo "Attempt $i failed, retrying in 30s..."
          sleep 30
        done

    - name: Health check - Staging Supabase API
      run: |
        curl -f https://${{ secrets.STAGING_DOMAIN }}/rest/v1/ \
          -H "apikey: ${{ secrets.STAGING_SUPABASE_ANON_KEY }}" || {
          echo "âŒ Staging Supabase API health check failed"
          exit 1
        }
        echo "âœ… Staging Supabase API health check passed"

    - name: Run basic smoke tests
      run: |
        # Test main pages
        curl -f https://${{ secrets.STAGING_DOMAIN }}/ || {
          echo "âŒ Homepage test failed"
          exit 1
        }
        
        # Test API endpoints
        curl -f https://${{ secrets.STAGING_DOMAIN }}/api/health || {
          echo "âŒ API health endpoint test failed"
          exit 1
        }
        
        echo "âœ… Basic smoke tests passed"

  notify-staging:
    name: Notify Staging Deployment
    runs-on: ubuntu-latest
    needs: [validate, deploy-staging, test-staging]
    if: always()
    
    steps:
    - name: Notify success
      if: needs.test-staging.result == 'success'
      run: |
        echo "ðŸŽ‰ Staging deployment successful!"
        echo "ðŸŒ Staging URL: https://${{ secrets.STAGING_DOMAIN }}"
        echo "ðŸ“Š Studio: https://${{ secrets.STAGING_DOMAIN }}/studio"
        echo "ðŸš€ Commit: ${{ github.sha }}"
        echo "ðŸ‘¤ Author: ${{ github.actor }}"
        echo "ðŸ”§ Mode: ${{ env.DEPLOYMENT_MODE }}"
        echo "âœ… Ready for production deployment"

    - name: Notify failure
      if: failure()
      run: |
        echo "âŒ Staging deployment failed!"
        echo "ðŸ” Check the logs for details"
        echo "ðŸš€ Commit: ${{ github.sha }}"
        echo "ðŸ‘¤ Author: ${{ github.actor }}"
        echo "ðŸ”§ Mode: ${{ env.DEPLOYMENT_MODE }}"
        echo "âš ï¸ Do not deploy to production"
        exit 1

  cleanup-staging:
    name: Cleanup Staging Artifacts
    runs-on: ubuntu-latest
    needs: [notify-staging]
    if: always()
    
    steps:
    - name: Cleanup artifacts
      run: |
        echo "ðŸ§¹ Cleaning up staging artifacts..."
        # Cleanup is handled automatically by GitHub Actions
        echo "âœ… Staging cleanup completed"